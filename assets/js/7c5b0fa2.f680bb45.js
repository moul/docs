"use strict";(self.webpackChunkosmosis_docs=self.webpackChunkosmosis_docs||[]).push([[4979],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},c=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),c=p(n),u=a,h=c["".concat(l,".").concat(u)]||c[u]||m[u]||i;return n?o.createElement(h,s(s({ref:t},d),{},{components:n})):o.createElement(h,s({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=c;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var p=2;p<i;p++)s[p]=n[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}c.displayName="MDXCreateElement"},12338:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var o=n(87462),a=(n(67294),n(3905));const i={},s="CosmWasm Pool",r={unversionedId:"modules/cosmwasmpool/README",id:"modules/cosmwasmpool/README",title:"CosmWasm Pool",description:"Overview",source:"@site/docs/osmosis-core/modules/cosmwasmpool/README.md",sourceDirName:"modules/cosmwasmpool",slug:"/modules/cosmwasmpool/",permalink:"/osmosis-core/modules/cosmwasmpool/",draft:!1,editUrl:"https://github.com/osmosis-labs/docs/tree/main/docs/osmosis-core/modules/cosmwasmpool/README.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Concentrated Liquidity",permalink:"/osmosis-core/modules/concentrated-liquidity/"},next:{title:"Downtime-detector",permalink:"/osmosis-core/modules/downtime-detector/"}},l={},p=[{value:"Overview",id:"overview",level:2},{value:"Key Components",id:"key-components",level:2},{value:"Creating new CosmWasm Pool",id:"creating-new-cosmwasm-pool",level:2},{value:"Providing / Withdrawing Liquidity",id:"providing--withdrawing-liquidity",level:2},{value:"Swap",id:"swap",level:2},{value:"Deactivating",id:"deactivating",level:2},{value:"CosmWasm Pool Contract Interface",id:"cosmwasm-pool-contract-interface",level:2},{value:"Query",id:"query",level:3},{value:"Sudo",id:"sudo",level:3},{value:"Incentives and Shares",id:"incentives-and-shares",level:2},{value:"Appendix",id:"appendix",level:2},{value:"TWAP",id:"twap",level:3},{value:"Rust de/serialization",id:"rust-deserialization",level:3},{value:"Governance and Code Id Management",id:"governance-and-code-id-management",level:3},{value:"1. Store code and update code id whitelist",id:"1-store-code-and-update-code-id-whitelist",level:4},{value:"2. Store code and migrate a specific code id to a new code id",id:"2-store-code-and-migrate-a-specific-code-id-to-a-new-code-id",level:4},{value:"Analysis of the Parameter Choice",id:"analysis-of-the-parameter-choice",level:5},{value:"3. Whitelist Management via Params",id:"3-whitelist-management-via-params",level:4},{value:"4. Pool Migration Limit via Params",id:"4-pool-migration-limit-via-params",level:4}],d={toc:p};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"cosmwasm-pool"},"CosmWasm Pool"),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"The CosmWasm Pool Module is an extension for the Osmosis pools, aiming to create a custom module that allows users to create and manage liquidity pools backed by CosmWasm smart contracts. The feature enables developers to build and deploy custom smart contracts that can be integrated with the rest of the pool types on the Osmosis chain."),(0,a.kt)("p",null,"The module is built on top of the CosmWasm smart contracting platform, which provides a secure and efficient way to develop and execute WebAssembly (Wasm) smart contracts on the Cosmos SDK."),(0,a.kt)("p",null,"Having pools in CosmWasm provides several benefits, one of which is avoiding the need for chain upgrades when introducing new functionalities or modifying existing ones related to liquidity pools. This advantage is particularly important in the context of speed of development and iteration."),(0,a.kt)("p",null,"An example of a CosmWasm pool type:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/osmosis-labs/transmuter"},"transmuter"))),(0,a.kt)("h2",{id:"key-components"},"Key Components"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Keeper"),": The module's keeper is responsible for managing the state of the CosmWasm pools, including creating and initializing pools,\nquerying pool data, and executing privileged operations such as swaps using the CosmWasm sudo message. ",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"InitializePool"),": Initializes a new CosmWasm pool by instantiating a Wasm contract and storing the pool model in the keeper."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Swap operations"),": Swap operations like ",(0,a.kt)("inlineCode",{parentName:"li"},"SwapExactAmountIn")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"SwapExactAmountOut")," are implemented, allowing users to perform swaps\nwithin the CosmWasm pools."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Swap estimation"),": Functions like CalcOutAmtGivenIn, and CalcInAmtGivenOut are provided to calculate prices and amounts for swap operations."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Pool information"),": Functions like ",(0,a.kt)("inlineCode",{parentName:"li"},"CalculateSpotPrice"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"GetPool"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"GetPoolAssets"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"GetPoolBalances"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"GetPoolTotalShares")," allow\nfor querying the state of the CosmWasm pools.")))),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Query and Sudo functions"),": The module includes generic functions to query CosmWasm smart contracts and execute sudo messages.\nThe Query and Sudo functions are used to interact with the smart contracts, while MustQuery and MustSudo variants panic if an error\noccurs during the query or sudo call, respectively.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"poolmanager.PoolI")," Interface"),": The CosmWasm Pool Model implements the PoolI interface from the Pool Manager Module to enable\nthe creation and management of liquidity pools backed by CosmWasm smart contracts. By implementing the PoolI interface, the model\nensures compatibility with the existing Pool Manager Module's structure and functionalities and integrates seamlessly with\nother modules such as ",(0,a.kt)("inlineCode",{parentName:"p"},"x/concentrated-liquidity")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"x/gamm"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"poolmanager.PoolModule")," Interface"),": To integrate the CosmWasm Pool Module with the existing Pool Manager Module,\nthe module's keeper has to implement the PoolModule interface from ",(0,a.kt)("inlineCode",{parentName:"p"},"x/poolmanager")," Module. By implementing the PoolModule interface,\nthe CosmWasm Pool Keeper can register itself as an extension to the existing Pool Manager Module and handle the creation and management\nof CosmWasm-backed liquidity pools as well as receive swaps propagated from the ",(0,a.kt)("inlineCode",{parentName:"p"},"x/poolmanager"),"."))),(0,a.kt)("h2",{id:"creating-new-cosmwasm-pool"},"Creating new CosmWasm Pool"),(0,a.kt)("p",null,"To create new CosmWasm Pool, there are 3 modules involved: ",(0,a.kt)("inlineCode",{parentName:"p"},"x/cosmwasmpool"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"x/wasm"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"x/poolmanager"),". Here is an overview of the process:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-mermaid"},"graph TD;\n  Sender((Sender))\n\n  Sender -- create poool --\x3e x/cosmwasmpool\n  x/cosmwasmpool -- get next & set pool id --\x3e x/poolmanager\n  x/cosmwasmpool -- instantiate contract --\x3e x/wasm\n")),(0,a.kt)("p",null,"The CosmWasm contract that is to be instanitiated needs to implement ",(0,a.kt)("a",{parentName:"p",href:"#cosmwasm-pool-contract-interface"},"CosmWasm Pool Contract Interface")," and store it on chain first. Then new pool can be created by sending ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgCreateCosmWasmPool"),"."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"MsgCreateCosmWasmPool")," contains ",(0,a.kt)("inlineCode",{parentName:"p"},"InstantiateMsg"),", which is a message that will be passed to the CosmWasm contract when it is instantiated. The structure of the message is defined by the contract developer, and can contain any information that the contract needs to be instantiated. JSON format is used for ",(0,a.kt)("inlineCode",{parentName:"p"},"InstantiateMsg"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-mermaid"},"sequenceDiagram\n    participant Sender\n    participant x/cosmwasmpool\n    participant x/poolmanager\n    participant x/wasm\n\n    Sender ->> x/cosmwasmpool: MsgCreateCosmWasmPool {CodeId, InstantiateMsg, Sender}\n\n    Note over x/wasm: Given there is a pool contract with CodeId\n\n    x/poolmanager ->> x/cosmwasmpool: Call GetNextPoolId()\n    x/cosmwasmpool ->> x/poolmanager: Call SetNextPoolId(poolId)\n\n    x/cosmwasmpool ->> x/wasm: Call InstantiateContract(CodeId, InstantiateMsg)\n    x/wasm --\x3e> x/cosmwasmpool: ContractAddress\n\n    Note over x/cosmwasmpool: Store CodeId, ContractAddress, and PoolId\n\n    x/cosmwasmpool --\x3e>  Sender: MsgCreateCosmWasmPoolResponse {PoolId}\n")),(0,a.kt)("h2",{id:"providing--withdrawing-liquidity"},"Providing / Withdrawing Liquidity"),(0,a.kt)("p",null,"Currently, all existing pool types have their own way of providing liquidity and shares calculation. CosmWasm pool aims to be flexible that regards and let the contract define the way of providing liquidity. So there is no restriction here, and the contract developer can define the way of providing liquidity as they wish, potentially with execute endpoint since ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgExecuteContract")," triggers state mutating endpoint and can also attach funds to it."),(0,a.kt)("p",null,"Common interface and later be defined for the contract to implement as spec and/or create a separated create for that purpose."),(0,a.kt)("p",null,"It's important to note that the ",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("strong",{parentName:"em"},"contract itself hold tokens that are provided by users")),"."),(0,a.kt)("h2",{id:"swap"},"Swap"),(0,a.kt)("p",null,"One of the main reason why CosmWasm pool is implemented as a module + contract rather than a contract only is that it allows us to use the existing pool manager module to handle swap, which means things like swap routing, cross chain swap, and other functionality that depends on existing pool interface works out of the box."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-mermaid"},"graph TD;\n  Sender((Sender))\n  Sender -- swap --\x3e x/poolmanager\n  x/poolmanager -- route msg to --\x3e x/cosmwasmpool\n  x/cosmwasmpool -- sudo execute contract --\x3e x/wasm\n  x/wasm -- sudo --\x3e wasm/pool\n\n  x/cosmwasmpool -- send token_in from sender to wasm/pool --\x3e x/bank\n  wasm/pool -- send token_out to sender --\x3e x/bank\n")),(0,a.kt)("p",null,"Pool contract's sudo endpoint expect the following message variant:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rs"},"/// SwapExactAmountIn swaps an exact amount of tokens in for as many tokens out as possible.\n/// The amount of tokens out is determined by the current exchange rate and the swap fee.\n/// The user specifies a minimum amount of tokens out, and the transaction will revert if that amount of tokens\n/// is not received.\nSwapExactAmountIn {\n    sender: String,\n    token_in: Coin,\n    token_out_denom: String,\n    token_out_min_amount: Uint128,\n    swap_fee: Decimal,\n},\n/// SwapExactAmountOut swaps as many tokens in as possible for an exact amount of tokens out.\n/// The amount of tokens in is determined by the current exchange rate and the swap fee.\n/// The user specifies a maximum amount of tokens in, and the transaction will revert if that amount of tokens\n/// is exceeded.\nSwapExactAmountOut {\n    sender: String,\n    token_in_denom: String,\n    token_in_max_amount: Uint128,\n    token_out: Coin,\n    swap_fee: Decimal,\n},\n")),(0,a.kt)("p",null,"The reason why this needs to be sudo endpoint, which can only be called by the chain itself, is that the chain can provide correct information about ",(0,a.kt)("inlineCode",{parentName:"p"},"swap_fee"),", which can be deviated from contract defined ",(0,a.kt)("inlineCode",{parentName:"p"},"swap_fee")," in multihop scenario."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"swap_fee")," in this context is intended to be fee that is collected by liquidity providers. If the contract provider wants to collect fee for itself, it should implement its own fee collection mechanism."),(0,a.kt)("p",null,"And because sudo message can't attach funds like execute message, chain-side is required to perform sending token to the contract and ensure that ",(0,a.kt)("inlineCode",{parentName:"p"},"token_in")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"token_in_max_amount")," is exactly the same amount of token that gets sent to the contract."),(0,a.kt)("h2",{id:"deactivating"},"Deactivating"),(0,a.kt)("p",null,"On contract's sudo endpoint, ",(0,a.kt)("inlineCode",{parentName:"p"},"SetActive")," can be called to deactivate the pool. This will prevent the pool from being used for swap, and also prevent users from providing liquidity to the pool. Contract needs to check if the pool is active before performing any state mutating operation except ",(0,a.kt)("inlineCode",{parentName:"p"},"SetActive"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rs"},"SetActive {\n    is_active: bool,\n}\n")),(0,a.kt)("p",null,"(TBD) On how to handle the deactivation operationally."),(0,a.kt)("h2",{id:"cosmwasm-pool-contract-interface"},"CosmWasm Pool Contract Interface"),(0,a.kt)("p",null,"The contract interface is defined so that ",(0,a.kt)("inlineCode",{parentName:"p"},"cosmwasmpool")," can delegate ",(0,a.kt)("inlineCode",{parentName:"p"},"PoolI")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"PoolModuleI")," calls to contract."),(0,a.kt)("p",null,"The following are the messages that the contract needs to implement. (If you have trouble interpreting this, please read ",(0,a.kt)("a",{parentName:"p",href:"#rust-deserialization"},"Rust de/serialization"),")"),(0,a.kt)("h3",{id:"query"},"Query"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rs"},"#[cw_serde]\n#[derive(QueryResponses)]\nenum QueryMessage {\n    /// GetSwapFee returns the pool's swap fee, based on the current state.\n    /// Pools may choose to make their swap fees dependent upon state\n    /// (prior TWAPs, network downtime, other pool states, etc.)\n    /// This is intended to be fee that is collected by liquidity providers.\n    /// If the contract provider wants to collect fee for itself, it should implement its own fee collection mechanism.\n    #[returns(GetSwapFeeResponse)]\n    GetSwapFee {},\n\n    /// Returns whether the pool has swaps enabled at the moment\n    #[returns(IsActiveResponse)]\n    IsActive {},\n\n    /// GetTotalShares returns the total number of LP shares in the pool\n\n    /// GetTotalPoolLiquidity returns the coins in the pool owned by all LPs\n    #[returns(TotalPoolLiquidityResponse)]\n    GetTotalPoolLiquidity {},\n\n    /// Returns the spot price of the 'base asset' in terms of the 'quote asset' in the pool,\n    /// errors if either baseAssetDenom, or quoteAssetDenom does not exist.\n    /// For example, if this was a UniV2 50-50 pool, with 2 ETH, and 8000 UST\n    /// pool.SpotPrice(ctx, \"eth\", \"ust\") = 4000.00\n    #[returns(SpotPriceResponse)]\n    SpotPrice {\n        quote_asset_denom: String,\n        base_asset_denom: String,\n    },\n\n    /// CalcOutAmtGivenIn calculates the amount of tokenOut given tokenIn and the pool's current state.\n    /// Returns error if the given pool is not a CFMM pool. Returns error on internal calculations.\n    #[returns(CalcOutAmtGivenInResponse)]\n    CalcOutAmtGivenIn {\n        token_in: Coin,\n        token_out_denom: String,\n        swap_fee: Decimal,\n    },\n\n    /// CalcInAmtGivenOut calculates the amount of tokenIn given tokenOut and the pool's current state.\n    /// Returns error if the given pool is not a CFMM pool. Returns error on internal calculations.\n    #[returns(CalcInAmtGivenOutResponse)]\n    CalcInAmtGivenOut {\n        token_out: Coin,\n        token_in_denom: String,\n        swap_fee: Decimal,\n    },\n}\n#[cw_serde]\npub struct GetSwapFeeResponse {\n    pub swap_fee: Decimal,\n}\n\n#[cw_serde]\npub struct IsActiveResponse {\n    pub is_active: bool,\n}\n\n#[cw_serde]\npub struct TotalPoolLiquidityResponse {\n    pub total_pool_liquidity: Vec<Coin>,\n}\n\n#[cw_serde]\npub struct SpotPriceResponse {\n    pub spot_price: Decimal,\n}\n\n#[cw_serde]\npub struct CalcOutAmtGivenInResponse {\n    pub token_out: Coin,\n}\n\n#[cw_serde]\npub struct CalcInAmtGivenOutResponse {\n    pub token_in: Coin,\n}\n")),(0,a.kt)("h3",{id:"sudo"},"Sudo"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rs"},"#[cw_serde]\npub enum SudoMessage {\n    /// SetActive sets the active status of the pool.\n    SetActive {\n        is_active: bool,\n    },\n    /// SwapExactAmountIn swaps an exact amount of tokens in for as many tokens out as possible.\n    /// The amount of tokens out is determined by the current exchange rate and the swap fee.\n    /// The user specifies a minimum amount of tokens out, and the transaction will revert if that amount of tokens\n    /// is not received.\n    SwapExactAmountIn {\n        sender: String,\n        token_in: Coin,\n        token_out_denom: String,\n        token_out_min_amount: Uint128,\n        swap_fee: Decimal,\n    },\n    /// SwapExactAmountOut swaps as many tokens in as possible for an exact amount of tokens out.\n    /// The amount of tokens in is determined by the current exchange rate and the swap fee.\n    /// The user specifies a maximum amount of tokens in, and the transaction will revert if that amount of tokens\n    /// is exceeded.\n    SwapExactAmountOut {\n        sender: String,\n        token_in_denom: String,\n        token_in_max_amount: Uint128,\n        token_out: Coin,\n        swap_fee: Decimal,\n    },\n}\n")),(0,a.kt)("h2",{id:"incentives-and-shares"},"Incentives and Shares"),(0,a.kt)("p",null,"In order to allow CosmWasm pool to work with the incentives module (or being composable in general),\nthe contract needs to be able to create share tokens."),(0,a.kt)("p",null,"We handle this by utilizing the ",(0,a.kt)("inlineCode",{parentName:"p"},"x/tokenfactory")," module.\nEach pool has share denom with this pattern: ",(0,a.kt)("inlineCode",{parentName:"p"},"factory/{contract_address}/cw-pool/{custom-name}"),"."),(0,a.kt)("p",null,"The contract address uniquely identifies a pool. We also use cw-pool to make these denoms distinguishable\nfrom other tokenfactory denoms and provide contracts the ability to customize the ",(0,a.kt)("inlineCode",{parentName:"p"},"{custom-name}"),"."),(0,a.kt)("p",null,"Each contract is responsible for minting and burning its token factory shares. The chain does no interaction with tokenfactory."),(0,a.kt)("p",null,"To integrate ",(0,a.kt)("inlineCode",{parentName:"p"},"x/cosmwasmpool")," into the ",(0,a.kt)("inlineCode",{parentName:"p"},"x/incentives")," module, it also needs to create gauges."),(0,a.kt)("p",null,"This can be done by setting ",(0,a.kt)("inlineCode",{parentName:"p"},"after_pool_created")," on ",(0,a.kt)("inlineCode",{parentName:"p"},"instantiate")," response."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rs"},'Ok(Response::new()\n    .add_attribute("method", "instantiate")\n    .add_attribute("contract_name", CONTRACT_NAME)\n    .add_attribute("contract_version", CONTRACT_VERSION)\n    // set `after_pool_created` information on response\n    // for `cosmwasmpool` module to process\n    .set_data(to_binary(&after_pool_created)?))\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"after_pool_created")," has type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rs"},"#[cw_serde]\npub struct AfterPoolCreated {\n    pub create_pool_guages: Option<CreatePoolGauges>,\n}\n\n#[cw_serde]\npub enum CreatePoolGauges {\n    // This works exactly like `gamm`'s.\n    DefaultLockableDurations {},\n    // Custom guages can be created.\n    Custom { msgs: Vec<MsgCreateGauge> },\n}\n")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"appendix"},"Appendix"),(0,a.kt)("h3",{id:"twap"},"TWAP"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"x/twap")," is not implemented for cosmwasm pools but can be in the future if there is a need."),(0,a.kt)("h3",{id:"rust-deserialization"},"Rust de/serialization"),(0,a.kt)("p",null,"Contract read these msg as JSON format. Here are some examples of how it is being de/serialized:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rs"},'// Notice that enum variant is turned into snake case and becomes the key of the JSON object.\nenum QueryMessage {\n    // { "spot_price": { "quote_asset_denom": "denom1", "base_asset_denom": "denom2" } }\n    SpotPrice {\n        quote_asset_denom: String,\n        base_asset_denom: String,\n    },\n}\n\n\n// In case of struct, the struct name is not used as the key,\n// since there is no need to distinguish between different structs.\nstruct SpotPriceResponse {\n    // { "spot_price": "0.001" }\n    pub spot_price: Decimal,\n}\n')),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/cosmwasm-std/1.2.3/cosmwasm_std/struct.Decimal.html"},"Decimal"),"  and ",(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/cosmwasm-std/1.2.3/cosmwasm_std/struct.Uint128.html"},"Uint128")," are represented as string in JSON."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/cosmwasm-std/1.2.3/cosmwasm_std/struct.Coin.html"},"Coin")," is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rs"},"pub struct Coin {\n    pub denom: String,\n    pub amount: Uint128,\n}\n")),(0,a.kt)("h3",{id:"governance-and-code-id-management"},"Governance and Code Id Management"),(0,a.kt)("p",null,"Despite code upload being permissioned by governance on Osmosis, it is allowed to be done by a certain\nset of addresses:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'osmosisd q wasm params\ncode_upload_access:\n  address: ""\n  addresses:\n  - osmo1cd4nn8yzdrrsfqsmmvaafq8r03xn38qgqt8fzh\n  - osmo1wl59k23zngj34l7d42y9yltask7rjlnxgccawc7ltrknp6n52fps94qsjd\n  - osmo19vxp8vq8qm368dr026qxh8v82satwaf79y235lfv6wmgpwxx8dtskedaku\n  - osmo1e0x2hnhhwyek7eq3kcxu2x6pt77wdnwz0lutz9fespdr9utq963qr0y5p5\n  - osmo14n3a65fnqz9jve85l23al6m3pjugf0atvrfqh5\n  - osmo15wna5dwylkuzvljsudyn6zfsd4zl0rkg5ge888mzk4vtnjpp0z5q4e9w58\n  - osmo1r02tlyyaqs6tmrfa4jf37t7ewuxr57qp8ghzly\n  permission: AnyOfAddresses\ninstantiate_default_permission: Everybody\n')),(0,a.kt)("p",null,"We would like to make sure that it is not possible to upload any pool code\nwithout governance approval. This is why we create two additional governance proposals:"),(0,a.kt)("p",null,"Note, that in both cases, x/cosmwasmpool module account will act as the admin and creator of the contract."),(0,a.kt)("h4",{id:"1-store-code-and-update-code-id-whitelist"},"1. Store code and update code id whitelist"),(0,a.kt)("p",null,"Proposal Name: ",(0,a.kt)("inlineCode",{parentName:"p"},"UploadCosmWasmPoolCodeAndWhiteListProposal")),(0,a.kt)("p",null,"On successful passing of this proposal, the code id of the pool contract will be added to the whitelist.\nAs a result, anyone would be able to instantiate a pool contract with this code id when creating a pol.\nNo address will be able to maliciously upload a new code id and instantiate a pool contract with it without\ngovernance approval."),(0,a.kt)("p",null,"Inputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"uploadByteCode")," - ",(0,a.kt)("inlineCode",{parentName:"li"},"[]byte")," - the raw wasm bytecode")),(0,a.kt)("p",null,"The created code id is emitted via ",(0,a.kt)("inlineCode",{parentName:"p"},"TypeEvtUploadedCosmwasmPoolCode")," event."),(0,a.kt)("h4",{id:"2-store-code-and-migrate-a-specific-code-id-to-a-new-code-id"},"2. Store code and migrate a specific code id to a new code id"),(0,a.kt)("p",null,"Proposal Name: ",(0,a.kt)("inlineCode",{parentName:"p"},"MigratePoolContractsProposal")),(0,a.kt)("p",null,"Similarly, if we want to migrate a contract, anyone can do so but they will need to go\nthrough a custom governance proposal."),(0,a.kt)("p",null,"Migrates all given cw pool contracts specified by their IDs. It has two options to perform the migration."),(0,a.kt)("p",null,"a. If the ",(0,a.kt)("inlineCode",{parentName:"p"},"codeID")," is non-zero, it will migrate the pool contracts to a given ",(0,a.kt)("inlineCode",{parentName:"p"},"codeID")," assuming that it has already been uploaded. uploadByteCode must be empty in such a case. Fails if ",(0,a.kt)("inlineCode",{parentName:"p"},"codeID")," does not exist. Fails if uploadByteCode is not empty."),(0,a.kt)("p",null,"b. If the ",(0,a.kt)("inlineCode",{parentName:"p"},"codeID")," is zero, it will upload the given ",(0,a.kt)("inlineCode",{parentName:"p"},"uploadByteCode")," and use the new resulting code id to migrate the pool to. Errors if uploadByteCode is empty or invalid."),(0,a.kt)("p",null,"In both cases, if one of the pools specified by the given ",(0,a.kt)("inlineCode",{parentName:"p"},"poolID")," does not exist, the proposal fails."),(0,a.kt)("p",null,"The reason for having ",(0,a.kt)("inlineCode",{parentName:"p"},"poolID"),"s be a slice of ids is to account for the potential need for emergency migration of all old code ids to new code ids, or simply having the flexibility of migrating multiple older pool contracts to a new one at once when there is a release."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"poolD"),"s must be at the most size of ",(0,a.kt)("inlineCode",{parentName:"p"},"PoolMigrationLimit")," module parameter. It is configured to 20 at launch.\nThe proposal fails if more. Note that 20 was chosen arbitrarily to have a constant bound on the number of pools migrated at once."),(0,a.kt)("p",null,"Inputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"poolIDs"),"        - ",(0,a.kt)("inlineCode",{parentName:"p"},"[]uint64"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"codeID"),"         - ",(0,a.kt)("inlineCode",{parentName:"p"},"uint64"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"uploadByteCode")," - ",(0,a.kt)("inlineCode",{parentName:"p"},"[]byte")),(0,a.kt)("p",{parentName:"li"},"If the code is uploaded via proposal, the resulting code id is emitted via ",(0,a.kt)("inlineCode",{parentName:"p"},"TypeEvtMigratedCosmwasmPoolCode"),"."))),(0,a.kt)("h5",{id:"analysis-of-the-parameter-choice"},"Analysis of the Parameter Choice"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Pros"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The flexibility is maximized as each pool id can be migrated individually either by uploading a new contract code or migrating to a pre-added one."),(0,a.kt)("li",{parentName:"ul"},"There is still an ability to migrate all pools belonging to a list of code ids. The max number of pools migrated at once is bounded by a constant parameter."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Cons"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If there are multiple iterations of the same type, It might become cumbersome to keep track of which pool is on which code id, why one is migrated and the other one is not"),(0,a.kt)("li",{parentName:"ul"},"Some conditionality with proposal parameters. For example, if ",(0,a.kt)("inlineCode",{parentName:"li"},"codeId")," is zero, byte code must be empty.")))),(0,a.kt)("p",null,"Overall, we concluded that pros outweigh the cons, and this is the best approach out of the other alternatives considered."),(0,a.kt)("h4",{id:"3-whitelist-management-via-params"},"3. Whitelist Management via Params"),(0,a.kt)("p",null,"Since the code id whitelist is implemented as a module parameter, in addition to\nthe previous two proposals, the whitelist can be updated via parameter change proposal\nto either add or remove a code id from the whitelist independently of the code upload."),(0,a.kt)("p",null,"The relevant parameter for changing is ",(0,a.kt)("inlineCode",{parentName:"p"},"CodeIdWhitelist")),(0,a.kt)("p",null,"Note, that the update to the parameter overwrites all previous values so the proposer\nshould be careful to include all code ids that should be whitelisted."),(0,a.kt)("h4",{id:"4-pool-migration-limit-via-params"},"4. Pool Migration Limit via Params"),(0,a.kt)("p",null,"Additionally, the maximum number of pools that can be migrated at once is also implemented\nas a parameter. It is initialized to 20 in the v16 upgrade handler. However, governance\ncan tweak it by changing the ",(0,a.kt)("inlineCode",{parentName:"p"},"PoolMigrationLimit")," parameter."))}m.isMDXComponent=!0}}]);