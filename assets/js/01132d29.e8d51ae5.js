"use strict";(self.webpackChunkosmosis_docs=self.webpackChunkosmosis_docs||[]).push([[3579],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),h=o,c=m["".concat(s,".").concat(h)]||m[h]||d[h]||i;return n?a.createElement(c,r(r({ref:t},u),{},{components:n})):a.createElement(c,r({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},21817:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(87462),o=(n(67294),n(3905));const i={},r="Generalized Solidly Stableswap",l={unversionedId:"modules/gamm/pool-models/stableswap/README",id:"modules/gamm/pool-models/stableswap/README",title:"Generalized Solidly Stableswap",description:"Stableswaps are pools that offer low slippage for two assets that are intended to be tightly correlated.",source:"@site/docs/osmosis-core/modules/gamm/pool-models/stableswap/README.md",sourceDirName:"modules/gamm/pool-models/stableswap",slug:"/modules/gamm/pool-models/stableswap/",permalink:"/osmosis-core/modules/gamm/pool-models/stableswap/",draft:!1,editUrl:"https://github.com/osmosis-labs/docs/tree/main/docs/osmosis-core/modules/gamm/pool-models/stableswap/README.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Create-pool",permalink:"/osmosis-core/modules/gamm/client/docs/create-pool"},next:{title:"Gov",permalink:"/osmosis-core/modules/gov/"}},s={},p=[{value:"Pool configuration",id:"pool-configuration",level:2},{value:"Scaling factor handling",id:"scaling-factor-handling",level:3},{value:"Algorithm details",id:"algorithm-details",level:2},{value:"CFMM function",id:"cfmm-function",level:3},{value:"Swaps",id:"swaps",level:3},{value:"Direct swap solution",id:"direct-swap-solution",level:4},{value:"Iterative search solution",id:"iterative-search-solution",level:4},{value:"Altering binary search equations due to error tolerance",id:"altering-binary-search-equations-due-to-error-tolerance",level:5},{value:"Combined pseudocode",id:"combined-pseudocode",level:5},{value:"Setting the error tolerance",id:"setting-the-error-tolerance",level:5},{value:"Further optimization",id:"further-optimization",level:5},{value:"Using this in swap methods",id:"using-this-in-swap-methods",level:4},{value:"SwapExactAmountIn",id:"swapexactamountin",level:5},{value:"SwapExactAmountOut",id:"swapexactamountout",level:5},{value:"Precision handling",id:"precision-handling",level:4},{value:"Proof that |e_y| &lt; 100|e_k|",id:"proof-that-e_y--100e_k",level:4},{value:"Spot Price",id:"spot-price",level:3},{value:"LP equations",id:"lp-equations",level:3},{value:"JoinPoolNoSwap and ExitPool",id:"joinpoolnoswap-and-exitpool",level:4},{value:"JoinPool",id:"joinpool",level:4},{value:"Join pool single asset in",id:"join-pool-single-asset-in",level:4},{value:"Code structure",id:"code-structure",level:2},{value:"Testing strategy",id:"testing-strategy",level:2}],u={toc:p};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"generalized-solidly-stableswap"},"Generalized Solidly Stableswap"),(0,o.kt)("p",null,"Stableswaps are pools that offer low slippage for two assets that are intended to be tightly correlated.\nThere is a price ratio they are expected to be at, and the AMM offers low slippage around this price.\nThere is still price impact for each trade, and as the liquidity becomes more lop-sided, the slippage drastically increases."),(0,o.kt)("p",null,"This package implements the Solidly stableswap curve, namely a CFMM with\ninvariant: $f(x, y) = xy(x^2 + y^2) = k$"),(0,o.kt)("p",null,"It is generalized to the multi-asset setting as $f(a_1, ..., a_n) = a_1 ",(0,o.kt)("em",{parentName:"p"}," ... ")," a_n (a_1^2 + ... + a_n^2)$"),(0,o.kt)("h2",{id:"pool-configuration"},"Pool configuration"),(0,o.kt)("p",null,"One key concept, is that the pool has a native concept of"),(0,o.kt)("h3",{id:"scaling-factor-handling"},"Scaling factor handling"),(0,o.kt)("p",null,"An important concept that's up to now, not been mentioned is how do we set the expected price ratio.\nIn the choice of curve section, we see that its the case that when ",(0,o.kt)("inlineCode",{parentName:"p"},"x_reserves ~= y_reserves"),", that spot price is very close to ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),". However, there are a couple issues with just this in practice:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Precision of pegged coins may differ. Suppose ",(0,o.kt)("inlineCode",{parentName:"li"},"1 Foo = 10^12 base units"),", whereas ",(0,o.kt)("inlineCode",{parentName:"li"},"1 WrappedFoo = 10^6 base units"),", but ",(0,o.kt)("inlineCode",{parentName:"li"},"1 Foo")," is expected to trade near the price of ",(0,o.kt)("inlineCode",{parentName:"li"},"1 Wrapped Foo"),"."),(0,o.kt)("li",{parentName:"ol"},"Relatedly, suppose there's a token called ",(0,o.kt)("inlineCode",{parentName:"li"},"TwoFoo")," which should trade around ",(0,o.kt)("inlineCode",{parentName:"li"},"1 TwoFoo = 2 Foo")),(0,o.kt)("li",{parentName:"ol"},"For staking derivatives, where value accrues within the token, the expected price to concentrate around dynamically changes (very slowly).")),(0,o.kt)("p",null,'To handle these cases, we introduce scaling factors. A scaling factor maps from "raw coin units" to "amm math units", by dividing.\nTo handle the first case, we would make ',(0,o.kt)("inlineCode",{parentName:"p"},"Foo")," have a scaling factor of ",(0,o.kt)("inlineCode",{parentName:"p"},"10^6"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"WrappedFoo")," have a scaling factor of ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),".\nThis mapping is done via ",(0,o.kt)("inlineCode",{parentName:"p"},"raw coin units / scaling factor"),".\nWe use a decimal object for amm math units, however we still have to be precise about how we round.\nWe introduce an enum ",(0,o.kt)("inlineCode",{parentName:"p"},"rounding mode")," for this, with three modes: ",(0,o.kt)("inlineCode",{parentName:"p"},"RoundUp"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"RoundDown"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"RoundBankers"),"."),(0,o.kt)("p",null,"The reserve units we pass into all AMM equations would then be computed based off the following reserves:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"scaled_Foo_reserves = decimal_round(pool.Foo_liquidity / 10^6, RoundingMode)\ndescaled_Foo_reserves = scaled_Foo_reserves * 10^6\n")),(0,o.kt)("p",null,"Similarly all token inputs would be scaled as such.\nThe AMM equations need to each ensure that rounding happens correctly,\nfor cases where the scaling factor doesn't perfectly divide into the liquidity.\nWe detail rounding modes and scaling details as pseudocode in the relevant sections of the spec.\n(And rounding modes for 'descaling' from AMM eq output to real liquidity amounts, via multiplying by the respective scaling factor)"),(0,o.kt)("h2",{id:"algorithm-details"},"Algorithm details"),(0,o.kt)("p",null,"The AMM pool interfaces requires implementing the following stateful methods:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-golang"},"    SwapOutAmtGivenIn(tokenIn sdk.Coins, tokenOutDenom string, swapFee sdk.Dec) (tokenOut sdk.Coin, err error)\n    SwapInAmtGivenOut(tokenOut sdk.Coins, tokenInDenom string, swapFee sdk.Dec) (tokenIn sdk.Coin, err error)\n\n    SpotPrice(baseAssetDenom string, quoteAssetDenom string) (sdk.Dec, error)\n\n    JoinPool(tokensIn sdk.Coins, swapFee sdk.Dec) (numShares sdk.Int, err error)\n    JoinPoolNoSwap(tokensIn sdk.Coins, swapFee sdk.Dec) (numShares sdk.Int, err error)\n    ExitPool(numShares sdk.Int, exitFee sdk.Dec) (exitedCoins sdk.Coins, err error)\n")),(0,o.kt)("p",null,'The "constant" part of CFMM\'s imply that we can reason about all their necessary algorithms from just the CFMM equation. There are still multiple ways to solve each method. We detail below the ways in which we do so. This is organized by first discussing variable substitutions we do, to be in a more amenable form, and then the details of how we implement each method.'),(0,o.kt)("h3",{id:"cfmm-function"},"CFMM function"),(0,o.kt)("p",null,"Most operations we do only need to reason about two of the assets in a pool, and sometimes only one.\nWe wish to have a simpler CFMM function to work within these cases.\nDue to the CFMM equation $f$ being a symmetric function, we can without loss of generality reorder the arguments to the function. Thus we put the assets of relevance at the beginning of the function. So if two assets $x, y$, we write: $f(x,y, a_3, ... a_n) = xy ",(0,o.kt)("em",{parentName:"p"}," a_3 ")," ... a_n (x^2 + y^2 + a_3^2 + ... + a_n^2)$."),(0,o.kt)("p",null,"We then take a more convenient expression to work with, via variable substitution."),(0,o.kt)("p",null,"$$\n\\begin{equation}\nv =\n\\begin{cases}\n1, & \\text{if } n=2 ","\\","\n\\prod\\negthinspace \\negthinspace \\thinspace^{n}_{i=3} \\space a_i, & \\text{otherwise}\n\\end{cases}\n\\end{equation}\n$$"),(0,o.kt)("p",null,"$$\n\\begin{equation}\nw =\n\\begin{cases}\n0, & \\text{if}\\ n=2 ","\\","\n\\sum\\negthinspace \\negthinspace \\thinspace^{n}_{i=3} \\space {a_i^2}, & \\text{otherwise}\n\\end{cases}\n\\end{equation}\n$$"),(0,o.kt)("p",null,"$$\\text{then } g(x,y,v,w) = xyv(x^2 + y^2 + w) = f(x,y, a_3, ... a_n)$$"),(0,o.kt)("p",null,"As a corollary, notice that $g(x,y,v,w) = v * g(x,y,1,w)$, which will be useful when we have to compare before and after quantities. We will use $h(x,y,w) := g(x,y,1,w)$ as short-hand for this."),(0,o.kt)("h3",{id:"swaps"},"Swaps"),(0,o.kt)("p",null,'The question we need to answer for a swap is "suppose I want to swap $a$ units of $x$, how many units $b$ of $y$ would I get out".'),(0,o.kt)("p",null,"Since we only deal with two assets at a time, we can then work with our prior definition of $g$. Let the input asset's reserves be $x$, the output asset's reserves be $y$, and we compute $v$ and $w$ given the other asset reserves, whose reserves are untouched throughout the swap."),(0,o.kt)("p",null,"First we note the direct way of solving this, its limitation, and then an iterative approximation approach that we implement."),(0,o.kt)("h4",{id:"direct-swap-solution"},"Direct swap solution"),(0,o.kt)("p",null,"The method to compute this under 0 swap fee is implied by the CFMM equation itself, since the constant refers to:\n$g(x_0, y_0, v, w) = k = g(x_0 + a, y_0 - b, v, w)$. As $k$ is linearly related to $v$, and $v$ is unchanged throughout the swap, we can simplify the equation to be reasoning about $k' = \\frac{k}{v}$ as the constant, and $h$ instead of $g$"),(0,o.kt)("p",null,"We then model the solution by finding a function $\\text{solve cfmm}(x, w, k') = y\\text{ s.t. }h(x, y, w) = k'$.\nThen we can solve the swap amount out by first computing $k'$ as $k' = h(x_0, y_0, w)$, and\ncomputing $y_f := \\text{solve cfmm}(x_0 + a, w, k')$. We then get that $b = y_0 - y_f$."),(0,o.kt)("p",null,"So all we need is an equation for $\\text{solve cfmm}$! Its essentially inverting a multi-variate polynomial, and in this case is solvable: ",(0,o.kt)("a",{parentName:"p",href:"https://www.wolframalpha.com/input?i=solve+for+y+in+x+*+y+*+%28x%5E2+%2B+y%5E2+%2B+w%29+%3D+k"},"wolfram alpha link")),(0,o.kt)("p",null,"Or if were clever with simplification in the two asset case, we can reduce it to: ",(0,o.kt)("a",{parentName:"p",href:"https://www.desmos.com/calculator/hag1f0wieg"},"desmos link"),"."),(0,o.kt)("p",null,"These functions are a bit complex, which is fine as they are easy to prove correct. However, they are relatively expensive to compute, the latter needs precision on the order of x^4, and requires computing multiple cubic roots."),(0,o.kt)("p",null,"Instead there is a more generic way to compute these, which we detail in the next subsection."),(0,o.kt)("h4",{id:"iterative-search-solution"},"Iterative search solution"),(0,o.kt)("p",null,"Instead of using the direct solution for $\\text{solve cfmm}(x, w, k')$, instead notice that $h(x, y, w)$ is an increasing function in $y$.\nSo we can simply binary search for $y$ such that $h(x, y, w) = k'$, and we are guaranteed convergence within some error bound."),(0,o.kt)("p",null,"In order to do a binary search, we need bounds on $y$.\nThe lowest lowerbound is $0$, and the largest upperbound is $\\infty$.\nThe maximal upperbound is obviously unworkable, and in general binary searching around wide ranges is unfortunate, as we expect most trades to be centered around $y_0$.\nThis would suggest that we should do something smarter to iteratively approach the right value for the upperbound at least.\nNotice that $h$ is super-linearly related in $y$, and at most cubically related to $y$.\nThis means that $\\forall c \\in \\mathbb{R}^+, c ",(0,o.kt)("em",{parentName:"p"}," h(x,y,w) < h(x,c"),"y,w) < c^3 * h(x,y,w)$.\nWe can use this fact to get a pretty-good initial upperbound guess for $y$ using the linear estimate.\nIn the lowerbound case, we leave it as lower-bounded by $0$, otherwise we would need to take a cubed root to get a better estimate."),(0,o.kt)("h5",{id:"altering-binary-search-equations-due-to-error-tolerance"},"Altering binary search equations due to error tolerance"),(0,o.kt)("p",null,"Great, we have a binary search to finding an input ",(0,o.kt)("inlineCode",{parentName:"p"},"new_y_reserve"),", such that we get a value ",(0,o.kt)("inlineCode",{parentName:"p"},"k")," within some error bound close to the true desired ",(0,o.kt)("inlineCode",{parentName:"p"},"k"),"! We can prove that an error by a factor of ",(0,o.kt)("inlineCode",{parentName:"p"},"e")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"k"),", implies an error of a factor less than ",(0,o.kt)("inlineCode",{parentName:"p"},"e")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"new_y_reserve"),". So we could set ",(0,o.kt)("inlineCode",{parentName:"p"},"e")," to be close to some correctness bound we want. Except... ",(0,o.kt)("inlineCode",{parentName:"p"},"new_y_reserve >> y_in"),', so we\'d need an extremely high error tolerance for this to work. So we actually want to adapt the equations, to reduce the "common terms" in ',(0,o.kt)("inlineCode",{parentName:"p"},"k")," that we need to binary search over, to help us search. To do this, we open up what are we doing again, and re-expose ",(0,o.kt)("inlineCode",{parentName:"p"},"y_out")," as a variable we explicitly search over (and therefore get error terms in ",(0,o.kt)("inlineCode",{parentName:"p"},"k")," implying error in ",(0,o.kt)("inlineCode",{parentName:"p"},"y_out"),")"),(0,o.kt)("p",null,"What we are doing above in the binary search is setting ",(0,o.kt)("inlineCode",{parentName:"p"},"k_target")," and searching over ",(0,o.kt)("inlineCode",{parentName:"p"},"y_f")," until we get ",(0,o.kt)("inlineCode",{parentName:"p"},"k_iter")," {within tolerance} to ",(0,o.kt)("inlineCode",{parentName:"p"},"k_target"),". Sine we want to change to iterating over $y",(0,o.kt)("em",{parentName:"p"},"{out}$, we unroll that $y_f = y_0 - y"),"{out}$ where they are defined as:\n$$k",(0,o.kt)("em",{parentName:"p"},"{target} = x_0 y_0 (x_0^2 + y_0^2 + w)$$\n$$k"),"{iter}(y",(0,o.kt)("em",{parentName:"p"},"0 - y"),"{out}) = h(x",(0,o.kt)("em",{parentName:"p"},"f, y_0 - y"),"{out}, w) = x",(0,o.kt)("em",{parentName:"p"},"f (y_0 - y"),"{out}) (x",(0,o.kt)("em",{parentName:"p"},"f^2 + (y_0 - y"),"{out})^2 + w)$$"),(0,o.kt)("p",null,"But we can remove many of these terms! First notice that ",(0,o.kt)("inlineCode",{parentName:"p"},"x_f")," is a constant factor in ",(0,o.kt)("inlineCode",{parentName:"p"},"k_iter"),", so we can just divide ",(0,o.kt)("inlineCode",{parentName:"p"},"k_target")," by ",(0,o.kt)("inlineCode",{parentName:"p"},"x_f")," to remove that. Then we switch what we search over, from ",(0,o.kt)("inlineCode",{parentName:"p"},"y_f")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"y_out"),", by fixing ",(0,o.kt)("inlineCode",{parentName:"p"},"y_0"),", so were at:"),(0,o.kt)("p",null,"$$k_{target} = x_0 y_0 (x_0^2 + y_0^2 + w) / x_f$$"),(0,o.kt)("p",null,"$$k",(0,o.kt)("em",{parentName:"p"},"{iter}(y"),"{out}) = (y",(0,o.kt)("em",{parentName:"p"},"0 - y"),"{out}) (x",(0,o.kt)("em",{parentName:"p"},"f^2 + (y_0 - y"),"{out})^2 + w) = (y",(0,o.kt)("em",{parentName:"p"},"0 - y"),"{out}) (x",(0,o.kt)("em",{parentName:"p"},"f^2 + w) + (y_0 - y"),"{out})^3$$"),(0,o.kt)("p",null,"So $k",(0,o.kt)("em",{parentName:"p"},"{iter}(y"),"{out})$ is a cubic polynomial in $y",(0,o.kt)("em",{parentName:"p"},"{out}$. Next we remove the terms that have no dependence on `y"),"{delta}` (the constant term in the polynomial). To do this first we rewrite this to make the polynomial clearer:"),(0,o.kt)("p",null,"$$k",(0,o.kt)("em",{parentName:"p"},"{iter}(y"),"{out}) = (y",(0,o.kt)("em",{parentName:"p"},"0 - y"),"{out}) (x",(0,o.kt)("em",{parentName:"p"},"f^2 + w) + y_0^3 - 3y_0^2 y"),"{out} + 3 y",(0,o.kt)("em",{parentName:"p"},"0 y"),"{out}^2 - y_{out}^3$$"),(0,o.kt)("p",null,"$$k",(0,o.kt)("em",{parentName:"p"},"{iter}(y"),"{out}) = y",(0,o.kt)("em",{parentName:"p"},"0 (x_f^2 + w) - y"),"{out}(x",(0,o.kt)("em",{parentName:"p"},"f^2 + w) + y_0^3 - 3y_0^2 y"),"{out} + 3 y",(0,o.kt)("em",{parentName:"p"},"0 y"),"{out}^2 - y_{out}^3$$"),(0,o.kt)("p",null,"$$k",(0,o.kt)("em",{parentName:"p"},"{iter}(y"),"{out}) = -y",(0,o.kt)("em",{parentName:"p"},"{out}^3 + 3 y_0 y"),"{out}^2 - (x",(0,o.kt)("em",{parentName:"p"},"f^2 + w + 3y_0^2)y"),"{out} + (y_0 (x_f^2 + w) + y_0^3)$$"),(0,o.kt)("p",null,"So we can subtract this constant term ",(0,o.kt)("inlineCode",{parentName:"p"},"y_0 (x_f^2 + w) + y_0^3"),", which for ",(0,o.kt)("inlineCode",{parentName:"p"},"y_out < y_0")," is the dominant term in the expression!"),(0,o.kt)("p",null,"So lets define this as:"),(0,o.kt)("p",null,"$$k_{target} = \\frac{x_0 y_0 (x_0^2 + y_0^2 + w)}{x_f} - (y_0 (x_f^2 + w) + y_0^3)$$"),(0,o.kt)("p",null,"$$k",(0,o.kt)("em",{parentName:"p"},"{iter}(y"),"{out}) = -y",(0,o.kt)("em",{parentName:"p"},"{out}^3 + 3 y_0 y"),"{out}^2 - (x",(0,o.kt)("em",{parentName:"p"},"f^2 + w + 3y_0^2)y"),"{out}$$"),(0,o.kt)("p",null,"We prove ",(0,o.kt)("a",{parentName:"p",href:"#err_proof"},"here")," that an error of a multiplicative ",(0,o.kt)("inlineCode",{parentName:"p"},"e")," between ",(0,o.kt)("inlineCode",{parentName:"p"},"target_k")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"iter_k"),", implies an error of less than a factor of ",(0,o.kt)("inlineCode",{parentName:"p"},"10e")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"y_{out}"),", as long as ",(0,o.kt)("inlineCode",{parentName:"p"},"|y_{out}| < y_0"),". (The proven bounds are actually better)"),(0,o.kt)("p",null,"We target an error of less than ",(0,o.kt)("inlineCode",{parentName:"p"},"10^{-8}")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"y_{out}"),", so we conservatively set a bound of ",(0,o.kt)("inlineCode",{parentName:"p"},"10^{-12}")," for ",(0,o.kt)("inlineCode",{parentName:"p"},"e_k"),"."),(0,o.kt)("h5",{id:"combined-pseudocode"},"Combined pseudocode"),(0,o.kt)("p",null,"Now we want to wrap this binary search into ",(0,o.kt)("inlineCode",{parentName:"p"},"solve_cfmm"),'. We changed the API slightly, from what was previously denoted, to have this "y_0" term, in order to derive initial bounds.'),(0,o.kt)("p",null,"One complexity is that in the iterative search, we iterate over $y_f$, but then translate to $y_0$ in the internal equations.\nSo we also use the "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# solve_y returns y_out s.t. CFMM_eq(x_f, y_f, w) = k = CFMM_eq(x_0, y_0, w)\n# for x_f = x_0 + x_in.\ndef solve_y(x_0, y_0, w, x_in):\n  x_f = x_0 + x_in\n  err_tolerance = {"within factor of 10^-12", RoundUp}\n  y_f = iterative_search(x_0, x_f, y_0, w, err_tolerance)\n  y_out = y_0 - y_f\n  return y_out\n\ndef iter_k_fn(x_f, y_0, w):\n  def f(y_f):\n    y_out = y_0 - y_f\n    return -(y_out)**3 + 3 y_0 * y_out^2 - (x_f**2 + w + 3*y_0**2) * y_out\n\ndef iterative_search(x_0, x_f, y_0, w, err_tolerance):\n  target_k = target_k_fn(x_0, y_0, w, x_f)\n  iter_k_calculator = iter_k_fn(x_f, y_0, w)\n\n  # use original CFMM to get y_f reserve bounds\n  bound_estimation_target_k = cfmm(x_0, y_0, w)\n  bound_estimation_k0 = cfmm(x_f, y_0, w)\n  lowerbound, upperbound = y_0, y_0\n  k_ratio = bound_estimation_k0 / bound_estimation_target_k\n  if k_ratio < 1:\n    # k_0 < k. Need to find an upperbound. Worst case assume a linear relationship, gives an upperbound\n    # We could derive better bounds via reasoning about coefficients in the cubic,\n    # however this is deemed as not worth it, since the solution is quite close\n    # when we are in the "stable" part of the curve.\n    upperbound = ceil(y_0 / k_ratio)\n  elif k_ratio > 1:\n    # need to find a lowerbound. We could use a cubic relation, but for now we just set it to 0.\n    lowerbound = 0\n  else:\n    return y_0 # means x_f = x_0\n  max_iteration_count = 100\n  return binary_search(lowerbound, upperbound, k_calculator, target_k, err_tolerance)\n\ndef binary_search(lowerbound, upperbound, approximation_fn, target, max_iteration_count, err_tolerance):\n  iter_count = 0\n  cur_k_guess = 0\n  while (not satisfies_bounds(cur_k_guess, target, err_tolerance)) and iter_count < max_iteration_count:\n    iter_count += 1\n    cur_y_guess = (lowerbound + upperbound) / 2\n    cur_k_guess = approximation_fn(cur_y_guess)\n\n    if cur_k_guess > target:\n      upperbound = cur_y_guess\n    else if cur_k_guess < target:\n      lowerbound = cur_y_guess\n\n  if iter_count == max_iteration_count:\n    return Error("max iteration count reached")\n\n  return cur_y_guess\n')),(0,o.kt)("h5",{id:"setting-the-error-tolerance"},"Setting the error tolerance"),(0,o.kt)("p",null,"What remains is setting the error tolerance. We need two properties:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The returned value to be within some correctness threshold of the true value"),(0,o.kt)("li",{parentName:"ul"},"The returned value to be rounded correctly (always ending with the user having fewer funds to avoid pool drain attacks). Mitigated by swap fees for normal swaps, but needed for 0-fee to be safe.")),(0,o.kt)("p",null,"The error tolerance we set is defined in terms of error in ",(0,o.kt)("inlineCode",{parentName:"p"},"k"),", which itself implies some error in ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),".\nAn error of ",(0,o.kt)("inlineCode",{parentName:"p"},"e_k")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"k"),", implies an error ",(0,o.kt)("inlineCode",{parentName:"p"},"e_y")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," that is less than ",(0,o.kt)("inlineCode",{parentName:"p"},"e_k"),". We prove this ",(0,o.kt)("a",{parentName:"p",href:"#err_proof"},"here")," (and show that ",(0,o.kt)("inlineCode",{parentName:"p"},"e_y")," is actually much less than the error in ",(0,o.kt)("inlineCode",{parentName:"p"},"e_k"),", but for simplicity ignore this fact). We want ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," to be within a factor of ",(0,o.kt)("inlineCode",{parentName:"p"},"10^(-12)")," of its true value.\nTo ensure the returned value is always rounded correctly, we define the rounding behavior expected."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If ",(0,o.kt)("inlineCode",{parentName:"li"},"x_in")," is positive, then we take ",(0,o.kt)("inlineCode",{parentName:"li"},"y_out")," units of ",(0,o.kt)("inlineCode",{parentName:"li"},"y")," out of the pool. ",(0,o.kt)("inlineCode",{parentName:"li"},"y_out")," should be rounded down. Note that ",(0,o.kt)("inlineCode",{parentName:"li"},"y_f < y_0")," here. Therefore to round ",(0,o.kt)("inlineCode",{parentName:"li"},"y_out = y_0 - y_f")," down, given fixed ",(0,o.kt)("inlineCode",{parentName:"li"},"y_0"),", we want to round ",(0,o.kt)("inlineCode",{parentName:"li"},"y_f")," up."),(0,o.kt)("li",{parentName:"ul"},"If ",(0,o.kt)("inlineCode",{parentName:"li"},"x_in")," is negative, then ",(0,o.kt)("inlineCode",{parentName:"li"},"y_out")," is also negative. The reason is that this is called in CalcInAmtGivenOut, so confusingly ",(0,o.kt)("inlineCode",{parentName:"li"},"x_in")," is the known amount out, as a negative quantity. ",(0,o.kt)("inlineCode",{parentName:"li"},"y_out")," is negative as well, to express that we get that many tokens out. (Since negative, ",(0,o.kt)("inlineCode",{parentName:"li"},"-y_out")," is how many we add into the pool). We want ",(0,o.kt)("inlineCode",{parentName:"li"},"y_out")," to be a larger negative, which means we want to round it down. Note that ",(0,o.kt)("inlineCode",{parentName:"li"},"y_f > y_0")," here. Therefore ",(0,o.kt)("inlineCode",{parentName:"li"},"y_out = y_0 - y_f")," is more negative, the higher ",(0,o.kt)("inlineCode",{parentName:"li"},"y_f")," is. Thus we want to round ",(0,o.kt)("inlineCode",{parentName:"li"},"y_f")," up.")),(0,o.kt)("p",null,"And therefore we round up in both cases."),(0,o.kt)("h5",{id:"further-optimization"},"Further optimization"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The astute observer may notice that the equation we are solving in $\\text{solve cfmm}$ is actually a cubic polynomial in $y$, with an always-positive derivative.\nWe should then be able to use newton's root finding algorithm to solve for the solution with quadratic convergence.\nWe do not pursue this today, due to other engineering tradeoffs, and insufficient analysis being done.")),(0,o.kt)("h4",{id:"using-this-in-swap-methods"},"Using this in swap methods"),(0,o.kt)("p",null,"So now we put together the components discussed in prior sections to achieve pseudocode for the SwapExactAmountIn\nand SwapExactAmountOut functions."),(0,o.kt)("p",null,"We assume existence of a function ",(0,o.kt)("inlineCode",{parentName:"p"},"pool.ScaledLiquidity(input, output, rounding_mode)")," that returns ",(0,o.kt)("inlineCode",{parentName:"p"},"in_reserve, out_reserve, rem_reserves"),", where each are scaled by their respective scaling factor using the provided rounding mode."),(0,o.kt)("h5",{id:"swapexactamountin"},"SwapExactAmountIn"),(0,o.kt)("p",null,"So now we need to put together the prior components.\nWhen we scale liquidity, we round down, as lower reserves -> higher slippage.\nSimilarly when we scale the token in, we round down as well.\nThese both ensure no risk of over payment."),(0,o.kt)("p",null,'The amount of tokens that we treat as going into the "0-swap fee" pool we defined equations off of is: ',(0,o.kt)("inlineCode",{parentName:"p"},"amm_in = in_amt_scaled * (1 - swapfee)"),". (With ",(0,o.kt)("inlineCode",{parentName:"p"},"swapfee * in_amt_scaled")," just being added to pool liquidity)"),(0,o.kt)("p",null,"Then we simply call ",(0,o.kt)("inlineCode",{parentName:"p"},"solve_y")," with the input reserves, and ",(0,o.kt)("inlineCode",{parentName:"p"},"amm_in"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def CalcOutAmountGivenExactAmountIn(pool, in_coin, out_denom, swap_fee):\n  in_reserve, out_reserve, rem_reserves = pool.ScaledLiquidity(in_coin, out_denom, RoundingMode.RoundDown)\n  in_amt_scaled = pool.ScaleToken(in_coin, RoundingMode.RoundDown)\n  amm_in = in_amt_scaled * (1 - swap_fee)\n  out_amt_scaled = solve_y(in_reserve, out_reserve, remReserves, amm_in)\n  out_amt = pool.DescaleToken(out_amt_scaled, out_denom)\n  return out_amt\n")),(0,o.kt)("h5",{id:"swapexactamountout"},"SwapExactAmountOut"),(0,o.kt)("p",null,"When we scale liquidity, we round down, as lower reserves -> higher slippage.\nSimilarly when we scale the exact token out, we round up to increase required token in."),(0,o.kt)("p",null,"We model the ",(0,o.kt)("inlineCode",{parentName:"p"},"solve_y")," call as we are doing a known change to the ",(0,o.kt)("inlineCode",{parentName:"p"},"out_reserve"),", and solving for the implied unknown change to ",(0,o.kt)("inlineCode",{parentName:"p"},"in_reserve"),".\nTo handle the swapfee, we apply the swapfee on the resultant needed input amount.\nWe do this by having ",(0,o.kt)("inlineCode",{parentName:"p"},"token_in = amm_in / (1 - swapfee)"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def CalcInAmountGivenExactAmountOut(pool, out_coin, in_denom, swap_fee):\n  in_reserve, out_reserve, rem_reserves = pool.ScaledLiquidity(in_denom, out_coin, RoundingMode.RoundDown)\n  out_amt_scaled = pool.ScaleToken(out_coin, RoundingMode.RoundUp)\n\n  amm_in_scaled = solve_y(out_reserve, in_reserve, remReserves, -out_amt_scaled)\n  swap_in_scaled = ceil(amm_in_scaled / (1 - swapfee))\n  in_amt = pool.DescaleToken(swap_in_scaled, in_denom)\n  return in_amt\n")),(0,o.kt)("p",null,"We see correctness of the swap fee, by imagining what happens if we took this resultant input amount, and ran ",(0,o.kt)("inlineCode",{parentName:"p"},"SwapExactAmountIn (seai)"),". Namely, that ",(0,o.kt)("inlineCode",{parentName:"p"},"seai_amm_in = amm_in * (1 - swapfee) = amm_in"),", as desired!"),(0,o.kt)("h4",{id:"precision-handling"},"Precision handling"),(0,o.kt)("p",null,"{Something we have to be careful of is precision handling, notes on why and how we deal with it.}"),(0,o.kt)("a",{name:"err_proof"},(0,o.kt)("h4",{id:"proof-that-e_y--100e_k"},"Proof that |e_y| < 100|e_k|")),(0,o.kt)("p",null,"The function $f(y",(0,o.kt)("em",{parentName:"p"},"{out}) = -y"),"{out}^3 + 3 y",(0,o.kt)("em",{parentName:"p"},"0 y"),"{out}^2 - (x",(0,o.kt)("em",{parentName:"p"},"f^2 + w + 3y_0^2)y"),"{out}$ is monotonically increasing over the reals.\nYou can prove this, by seeing that its ",(0,o.kt)("a",{parentName:"p",href:"https://www.wolframalpha.com/input?i=d%2Fdx+-x%5E3+%2B+3a+x%5E2+-+%28b+%2B+3a%5E2%29+x+"},"derivative's")," 0 values are both imaginary, and therefore has no local minima or maxima in the reals.\nTherefore, there exists exactly one real $y",(0,o.kt)("em",{parentName:"p"},"{out}$ s.t. $f(y"),"{out}) = k$.\nVia binary search, we solve for a value $y",(0,o.kt)("em",{parentName:"p"},"{out}^{","*","}$ such that $\\left|\\frac{ k - k^{","*","} }{k}\\right| < e_k$, where $k^{","*","} = f(y"),"{out}^{","*","})$. We seek to then derive bounds on $e",(0,o.kt)("em",{parentName:"p"},"y = \\left|\\frac{ y"),"{out} - y",(0,o.kt)("em",{parentName:"p"},"{out}^{","*","} }{y"),"{out}}\\right|$ in relation to $e_k$."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Theorem"),": $e",(0,o.kt)("em",{parentName:"p"},"y < 100 e_k$ as long as $|y"),"{out}| <= .9y",(0,o.kt)("em",{parentName:"p"},"0$.\n",(0,o.kt)("strong",{parentName:"em"},"Informal"),", we claim that for $.9y_0 < |y"),"{out}| < y",(0,o.kt)("em",{parentName:"p"},"0$, ",(0,o.kt)("inlineCode",{parentName:"em"},"e_y"),' is "close" to ',(0,o.kt)("inlineCode",{parentName:"em"},"e_k")," under expected parameterizations. And for $y"),"{out}$ significantly less than $.9y_0$, the error bounds are much better. (Often better than $e_k$)"),(0,o.kt)("p",null,"Let $y",(0,o.kt)("em",{parentName:"p"},"{out} - y"),"{out}^",(0,o.kt)("em",{parentName:"p"}," = a",(0,o.kt)("em",{parentName:"em"},"y$, we are going to assume that $a_y << y"),"{out}$, and will justify this later. But due to this, we treat $a",(0,o.kt)("em",{parentName:"em"},"y^c = 0$ for $c > 1$. This then implies that $y"),"{out}^2 - y_{out}^{"),"2} = y",(0,o.kt)("em",{parentName:"p"},"{out}^2 - (y"),"{out} - a",(0,o.kt)("em",{parentName:"p"},"y)^2 \\approx 2y"),"{out}a",(0,o.kt)("em",{parentName:"p"},"y$, and similarly $y"),"{out}^3 - y",(0,o.kt)("em",{parentName:"p"},"{out}^{*3} \\approx 3y"),"{out}^2 a_y$"),(0,o.kt)("p",null,"Now we are prepared to start bounding this.\n$$k - k^{","*","} = -(y",(0,o.kt)("em",{parentName:"p"},"{out}^3 - y"),"{out}^{3","*","}) + 3y",(0,o.kt)("em",{parentName:"p"},"0(y"),"{out}^2 - y",(0,o.kt)("em",{parentName:"p"},"{out}^{2","*","}) - (x_f^2 + w + 3y_0^2)(y"),"{out} - y_{out}^{","*","})$$"),(0,o.kt)("p",null,"$$k - k^{","*","} \\approx -(3y",(0,o.kt)("em",{parentName:"p"},"{out}^2 a_y) + 3y_0 (2y"),"{out}a_y) - (x_f^2 + w + 3y_0^2)a_y$$"),(0,o.kt)("p",null,"$$k - k^{","*","} \\approx a",(0,o.kt)("em",{parentName:"p"},"y(-3y"),"{out}^2 + 6y",(0,o.kt)("em",{parentName:"p"},"0y"),"{out} - (x_f^2 + w + 3y_0^2))$$"),(0,o.kt)("p",null,"Rewrite $k = y",(0,o.kt)("em",{parentName:"p"},"{out}(-y"),"{out}^2 + 3y",(0,o.kt)("em",{parentName:"p"},"0y"),"{out} - (x_f^2 + w + 3y_0^2))$"),(0,o.kt)("p",null,"$$e",(0,o.kt)("em",{parentName:"p"},"k > \\left|\\frac{ k - k^{","*","} }{k}\\right| = \\left|\\frac{a_y}{y"),"{out}} \\frac{(-3y",(0,o.kt)("em",{parentName:"p"},"{out}^2 + 6y_0y"),"{out} - (x",(0,o.kt)("em",{parentName:"p"},"f^2 + w + 3y_0^2))}{(-y"),"{out}^2 + 3y",(0,o.kt)("em",{parentName:"p"},"0y"),"{out} - (x_f^2 + w + 3y_0^2))}\\right|$$"),(0,o.kt)("p",null,"Notice that $\\left|\\frac{a",(0,o.kt)("em",{parentName:"p"},"y}{y"),"{out}}\\right| = e_y$! Therefore"),(0,o.kt)("p",null,"$$e",(0,o.kt)("em",{parentName:"p"},"k > e_y\\left|\\frac{(-3y"),"{out}^2 + 6y",(0,o.kt)("em",{parentName:"p"},"0y"),"{out} - (x",(0,o.kt)("em",{parentName:"p"},"f^2 + w + 3y_0^2))}{(-y"),"{out}^2 + 3y",(0,o.kt)("em",{parentName:"p"},"0y"),"{out} - (x_f^2 + w + 3y_0^2))}\\right|$$"),(0,o.kt)("p",null,"We bound the right hand side, with the assistance of wolfram alpha. Let $a = y_{out}, b = y_0, c = x_f^2 + w$. Then we see from ",(0,o.kt)("a",{parentName:"p",href:"https://www.wolframalpha.com/input?i=%7C%28-3a%5E2+%2B+6ab+-+%28c+%2B+3b%5E2%29%29+%2F+%28-a%5E2+%2B+3ab+-+%28c+%2B+3b%5E2%29%29+%7C+%3E+.01"},"wolfram alpha here"),", that this right hand expression is provably greater than ",(0,o.kt)("inlineCode",{parentName:"p"},".01")," if some set of decisions hold. We describe the solution set that satisfies our use case here:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When $y_{out} > 0$",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Use solution set: $a > 0, b > \\frac{2}{3} a, c > \\frac{1}{99} (-299a^2 + 597ab - 297b^2)$",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"$a > 0$ by definition."),(0,o.kt)("li",{parentName:"ul"},"$b > \\frac{2}{3} a$, as that's equivalent to $y",(0,o.kt)("em",{parentName:"li"},"0 > \\frac{2}{3} y"),"{out}$. We already assume that $y",(0,o.kt)("em",{parentName:"li"},"0 >= y"),"{out}$."),(0,o.kt)("li",{parentName:"ul"},"Set $y_{out} = .9y_0$, per our theorem assumption. So $b = .9a$. Take $c = x^2 + w = 0$. Then ",(0,o.kt)("a",{parentName:"li",href:"https://www.wolframalpha.com/input?i=0+%3E+-299a%5E2+%2B+597ab+-+297b%5E2%2C+when+b%3D+.90a"},"we can show that")," $(-299a^2 + 597ab - 297b^2) < 0$ for all $a$. This completes the constraint set."))))),(0,o.kt)("li",{parentName:"ul"},"When $y_{out} < 0$",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Use solution set: $a < 0, b > \\frac{2}{3} a, c > -a^2 + 3ab - 3b^2$",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"$a < 0$ by definition."),(0,o.kt)("li",{parentName:"ul"},"$b > \\frac{2}{3} a$, as $y_0$ is positive."),(0,o.kt)("li",{parentName:"ul"},"$c > 0$ is by definition, so we just need to bound when $-a^2 + 3ab - 3b^2 < 0$. This is always the case as long as one of $a$ or $b$ is non-zero, per ",(0,o.kt)("a",{parentName:"li",href:"https://www.wolframalpha.com/input?i=-a%5E2+%2B+3ab+-+3b%5E2+%3C+0"},"here"),".")))))),(0,o.kt)("p",null,"Tying this all together, we have that $e_k > .01e_y$. Therefore $e_y < 100 e_k$, satisfying our theoerem!"),(0,o.kt)("p",null,"To show the informal claims, the constraint that led to this 100x error blowup was trying to accommodate high $y",(0,o.kt)("em",{parentName:"p"},"{out}$. When $y"),"{out}$ is smaller, the error is far lower. (Often to the case that $e",(0,o.kt)("em",{parentName:"p"},"y < e_k$, you can convince yourself of this by setting the ratio to being greater than 1 in wolfram alpha) When $y"),"{out}$ is bigger than $.9y_0$, we can rely on x_f^2 + w being much larger to lower this error. In these cases, the $x_f$ term must be large relative to $y_0$, which would yield a far better error bound."),(0,o.kt)("p",null,"TODO: Justify a_y << y_out. (This should be easy, assume its not, that leads to e_k being high. Ratio test probably easiest. Maybe just add a sentence to that effect)"),(0,o.kt)("h3",{id:"spot-price"},"Spot Price"),(0,o.kt)("p",null,"Spot price for an AMM pool is the derivative of its ",(0,o.kt)("inlineCode",{parentName:"p"},"CalculateOutAmountGivenIn")," equation.\nHowever for the stableswap equation, this is painful: ",(0,o.kt)("a",{parentName:"p",href:"https://www.wolframalpha.com/input?i=dy%2Fdx+of+y+%3D+%28sqrt%28729+k%5E2+x%5E4+%2B+108+x%5E3+%28w+x+%2B+x%5E3%29%5E3%29+%2B+27+k+x%5E2%29%5E%281%2F3%29%2F%283+2%5E%281%2F3%29+x%29+-+%282%5E%281%2F3%29+%28w+x+%2B+x%5E3%29%29%2F%28sqrt%28729+k%5E2+x%5E4+%2B+108+x%5E3+%28w+x+%2B+x%5E3%29%5E3%29+%2B+27+k+x%5E2%29%5E%281%2F3%29+"},"wolfram alpha link")),(0,o.kt)("p",null,"So instead we compute the spot price by approximating the derivative via a small swap."),(0,o.kt)("p",null,"Let $\\epsilon$ be a sentinel very small swap in amount."),(0,o.kt)("p",null,"Then $\\text{spot price} = \\frac{\\text{CalculateOutAmountGivenIn}(\\epsilon)}{\\epsilon}$."),(0,o.kt)("h3",{id:"lp-equations"},"LP equations"),(0,o.kt)("p",null,"We divide this section into two parts, ",(0,o.kt)("inlineCode",{parentName:"p"},"JoinPoolNoSwap & ExitPool"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"JoinPool"),"."),(0,o.kt)("p",null,"First we recap what are the properties that we'd expect from ",(0,o.kt)("inlineCode",{parentName:"p"},"JoinPoolNoSwap"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ExitPool"),", and LP shares.\nFrom this, we then derive what we'd expect for ",(0,o.kt)("inlineCode",{parentName:"p"},"JoinPool"),"."),(0,o.kt)("h4",{id:"joinpoolnoswap-and-exitpool"},"JoinPoolNoSwap and ExitPool"),(0,o.kt)("p",null,"Both of these methods can be implemented via generic AMM techniques.\n(Link to them or describe the idea)"),(0,o.kt)("h4",{id:"joinpool"},"JoinPool"),(0,o.kt)("p",null,"The JoinPool API only supports JoinPoolNoSwap if"),(0,o.kt)("h4",{id:"join-pool-single-asset-in"},"Join pool single asset in"),(0,o.kt)("p",null,"There are a couple ways to define ",(0,o.kt)("inlineCode",{parentName:"p"},"JoinPoolSingleAssetIn"),". The simplest way is to define it from its intended relation from the CFMM, with Exit pool. We describe this below under the zero swap fee case."),(0,o.kt)("p",null,"Let ",(0,o.kt)("inlineCode",{parentName:"p"},"pool_{L, S}")," represent a pool with liquidity ",(0,o.kt)("inlineCode",{parentName:"p"},"L"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"S")," total LP shares.\nIf we call ",(0,o.kt)("inlineCode",{parentName:"p"},"pool_{L, S}.JoinPoolSingleAssetIn(tokensIn) -> (N, pool_{L + tokensIn, S + N})"),", or in others we get out ",(0,o.kt)("inlineCode",{parentName:"p"},"N")," new LP shares, and a pool with with tokensIn added to liquidity.\nIt must then be the case that ",(0,o.kt)("inlineCode",{parentName:"p"},"pool_{L+tokensIn, S+N}.ExitPool(N) -> (tokensExited, pool_{L + tokensIn - tokensExited, S})"),".\nThen if we swap all of ",(0,o.kt)("inlineCode",{parentName:"p"},"tokensExited")," back to tokensIn, under 0 swap fee, we should get back to ",(0,o.kt)("inlineCode",{parentName:"p"},"pool_{L, S}")," under the CFMM property."),(0,o.kt)("p",null,"In other words, if we single asset join pool, and then exit pool, we should return back to the same CFMM ",(0,o.kt)("inlineCode",{parentName:"p"},"k")," value we started with. Then if we swap back to go entirely back into our input asset, we should have exactly many tokens as we started with, under 0 swap fee."),(0,o.kt)("p",null,"We can solve this relation with a binary search over the amount of LP shares to give!"),(0,o.kt)("p",null,'Thus we are left with how to account swap fee. We currently account for swap fee, by considering the asset ratio in the pool. If post scaling factors, the pool liquidity is say 60:20:20, where 60 is the asset were bringing in, then we consider "only (1 - 60%) = 40%" of the input as getting swapped. So we charge the swap fee on 40% of our single asset join in input. So the pseudocode for this is roughly:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def JoinPoolSingleAssetIn(pool, tokenIn):\n  swapFeeApplicableFraction = 1 - (pool.ScaledLiquidityOf(tokenIn.Denom) / pool.SumOfAllScaledLiquidity())\n  effectiveSwapFee = pool.SwapFee * swapFeeApplicableFraction\n  effectiveTokenIn = RoundDown(tokenIn * (1 - effectiveSwapFee))\n  return BinarySearchSingleJoinLpShares(pool, effectiveTokenIn)\n")),(0,o.kt)("p",null,"We leave the rounding mode for the scaling factor division unspecified.\nThis is because its expected to be tiny (as the denominator is larger than the numerator, and we are operating in BigDec),\nand it should be dominated by the later step of rounding down."),(0,o.kt)("h2",{id:"code-structure"},"Code structure"),(0,o.kt)("h2",{id:"testing-strategy"},"Testing strategy"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Unit tests for every pool interface method"),(0,o.kt)("li",{parentName:"ul"},"Msg tests for custom messages",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"CreatePool"),(0,o.kt)("li",{parentName:"ul"},"SetScalingFactors"))),(0,o.kt)("li",{parentName:"ul"},"Simulator integrations:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Pool creation"),(0,o.kt)("li",{parentName:"ul"},"JoinPool + ExitPool gives a token amount out that is lte input"),(0,o.kt)("li",{parentName:"ul"},"SingleTokenIn + ExitPool + Swap to base token gives a token amount that is less than input"),(0,o.kt)("li",{parentName:"ul"},"CFMM k adjusting in the correct direction after every action"))),(0,o.kt)("li",{parentName:"ul"},"Fuzz test binary search algorithm, to see that it still works correctly across wide scale ranges"),(0,o.kt)("li",{parentName:"ul"},"Fuzz test approximate equality of iterative approximation swap algorithm and direct equation swap."),(0,o.kt)("li",{parentName:"ul"},"Flow testing the entire stableswap scaling factor update process")))}d.isMDXComponent=!0}}]);