"use strict";(self.webpackChunkosmosis_docs=self.webpackChunkosmosis_docs||[]).push([[230],{3905:(e,t,o)=>{o.d(t,{Zo:()=>u,kt:()=>c});var n=o(67294);function a(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function l(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){a(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function i(e,t){if(null==e)return{};var o,n,a=function(e,t){if(null==e)return{};var o,n,a={},r=Object.keys(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||(a[o]=e[o]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(a[o]=e[o])}return a}var p=n.createContext({}),s=function(e){var t=n.useContext(p),o=t;return e&&(o="function"==typeof e?e(t):l(l({},t),e)),o},u=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var o=e.components,a=e.mdxType,r=e.originalType,p=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=s(o),c=a,g=d["".concat(p,".").concat(c)]||d[c]||m[c]||r;return o?n.createElement(g,l(l({ref:t},u),{},{components:o})):n.createElement(g,l({ref:t},u))}));function c(e,t){var o=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=o.length,l=new Array(r);l[0]=d;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var s=2;s<r;s++)l[s]=o[s];return n.createElement.apply(null,l)}return n.createElement.apply(null,o)}d.displayName="MDXCreateElement"},24966:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>s});var n=o(87462),a=(o(67294),o(3905));const r={},l="Pool Manager Module",i={unversionedId:"modules/pool-manager/README",id:"modules/pool-manager/README",title:"Pool Manager Module",description:"The poolmanager module exists as a swap entrypoint for any pool model",source:"@site/docs/osmosis-core/modules/pool-manager/README.md",sourceDirName:"modules/pool-manager",slug:"/modules/pool-manager/",permalink:"/osmosis-core/modules/pool-manager/",draft:!1,editUrl:"https://github.com/osmosis-labs/docs/tree/main/docs/osmosis-core/modules/pool-manager/README.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Pool Incentives",permalink:"/osmosis-core/modules/pool-incentives/"},next:{title:"Osmosis modules",permalink:"/osmosis-core/modules/protorev/"}},p={},s=[{value:"Pool Creation &amp; Id Management",id:"pool-creation--id-management",level:2},{value:"Swaps",id:"swaps",level:2},{value:"Messages",id:"messages",level:2},{value:"MsgSwapExactAmountIn",id:"msgswapexactamountin",level:3},{value:"MsgSwapExactAmountOut",id:"msgswapexactamountout",level:3},{value:"MsgSplitRouteSwapExactAmountIn",id:"msgsplitrouteswapexactamountin",level:3},{value:"MsgSplitRouteSwapExactAmountOut",id:"msgsplitrouteswapexactamountout",level:2},{value:"Multi-Hop",id:"multi-hop",level:2},{value:"Route Splitting",id:"route-splitting",level:2}],u={toc:s};function m(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,n.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"pool-manager-module"},"Pool Manager Module"),(0,a.kt)("p",null,"The poolmanager module exists as a swap entrypoint for any pool model\nthat exists on the chain. The poolmanager module is responsible for routing\nswaps across various pools. It also performs pool-id management for\nany on-chain pool."),(0,a.kt)("p",null,"The user-stories for this module follow:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"As a user, I would like to have a unified entrypoint for my swaps regardless\nof the underlying pool implementation so that I don't need to reason about\nAPI complexity")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"As a user, I would like the pool management to be unified so that I don't\nhave to reason about additional complexity stemming from divergent pool sources.")),(0,a.kt)("p",null,"We have multiple pool-storage modules. Namely, ",(0,a.kt)("inlineCode",{parentName:"p"},"x/gamm")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"x/concentrated-liquidity"),"."),(0,a.kt)("p",null,"To avoid fragmenting swap and pool creation entrypoints and duplicating their boilerplate logic,\nwe define a ",(0,a.kt)("inlineCode",{parentName:"p"},"poolmanager")," module. Its purpose is twofold:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Handle pool creation",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Assign ids to pools"),(0,a.kt)("li",{parentName:"ul"},"Store the mapping from pool id to one of the swap modules (",(0,a.kt)("inlineCode",{parentName:"li"},"gamm")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"concentrated-liquidity"),")"),(0,a.kt)("li",{parentName:"ul"},"Propagate the execution to the appropriate module depending on the pool type."),(0,a.kt)("li",{parentName:"ul"},"Note, that pool creation messages are received by the pool model's message server.\nEach module's message server then calls the ",(0,a.kt)("inlineCode",{parentName:"li"},"x/poolmanager")," keeper method ",(0,a.kt)("inlineCode",{parentName:"li"},"CreatePool"),"."))),(0,a.kt)("li",{parentName:"ol"},"Handle swaps",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Cover & share multihop logic"),(0,a.kt)("li",{parentName:"ul"},"Propagate intra-pool swaps to the appropriate module depending on the pool type."),(0,a.kt)("li",{parentName:"ul"},"Contrary to pool creation, swap messages are received by the ",(0,a.kt)("inlineCode",{parentName:"li"},"x/poolmanager")," message server.")))),(0,a.kt)("p",null,"Let's consider pool creation and swaps separately and in more detail."),(0,a.kt)("h2",{id:"pool-creation--id-management"},"Pool Creation & Id Management"),(0,a.kt)("p",null,"To make sure that the pool ids are unique across the two modules, we unify pool id management\nin the ",(0,a.kt)("inlineCode",{parentName:"p"},"poolmanager"),"."),(0,a.kt)("p",null,"When a call to ",(0,a.kt)("inlineCode",{parentName:"p"},"CreatePool")," keeper method is received, we get the next pool id from the module\nstorage, assign it to the new pool, and propagate the execution to either ",(0,a.kt)("inlineCode",{parentName:"p"},"gamm"),"\nor ",(0,a.kt)("inlineCode",{parentName:"p"},"concentrated-liquidity")," modules."),(0,a.kt)("p",null,"Note that we define a ",(0,a.kt)("inlineCode",{parentName:"p"},"CreatePoolMsg")," interface:\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/osmosis/blob/f26ceb958adaaf31510e17ed88f5eab47e2bac03/x/poolmanager/types/msg_create_pool.go#L9"},"https://github.com/osmosis-labs/osmosis/blob/f26ceb958adaaf31510e17ed88f5eab47e2bac03/x/poolmanager/types/msg_create_pool.go#L9")),(0,a.kt)("p",null,"Each ",(0,a.kt)("inlineCode",{parentName:"p"},"balancer"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"stableswap")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"concentrated-liquidity")," pool has its own implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"CreatePoolMsg"),"."),(0,a.kt)("p",null,"Note the ",(0,a.kt)("inlineCode",{parentName:"p"},"PoolType")," type. This is an enumeration of all supported pool types.\nWe proto-generate this enumeration:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// proto/osmosis/poolmanager/v1beta1/module_route.proto\n// generates to x/poolmanager/types/module_route.pb.go\n\n// PoolType is an enumeration of all supported pool types.\nenum PoolType {\n  option (gogoproto.goproto_enum_prefix) = false;\n\n  // Balancer is the standard xy=k curve. Its pool model is defined in x/gamm.\n  Balancer = 0;\n  // Stableswap is the Solidly cfmm stable swap curve. Its pool model is defined\n  // in x/gamm.\n  StableSwap = 1;\n  // Concentrated is the pool model specific to concentrated liquidity. It is\n  // defined in x/concentrated-liquidity.\n  Concentrated = 2;\n}\n")),(0,a.kt)("p",null,"Let's begin by considering the execution flow of the pool creation message.\nAssume ",(0,a.kt)("inlineCode",{parentName:"p"},"balancer")," pool is being created."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"CreatePoolMsg")," is received by the ",(0,a.kt)("inlineCode",{parentName:"p"},"x/gamm")," message server.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"CreatePool")," keeper method is called from ",(0,a.kt)("inlineCode",{parentName:"p"},"poolmanager"),", propagating\nthe appropriate implementation of the ",(0,a.kt)("inlineCode",{parentName:"p"},"CreatePoolMsg")," interface."))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// x/poolmanager/creator.go CreatePool(...)\n\n// CreatePool attempts to create a pool returning the newly created pool ID or\n// an error upon failure. The pool creation fee is used to fund the community\n// pool. It will create a dedicated module account for the pool and sends the\n// initial liquidity to the created module account.\n//\n// After the initial liquidity is sent to the pool's account, this function calls an\n// InitializePool function from the source module. That module is responsible for:\n// - saving the pool into its own state\n// - Minting LP shares to pool creator\n// - Setting metadata for the shares\nfunc (k Keeper) CreatePool(ctx sdk.Context, msg types.CreatePoolMsg) (uint64, error) {\n    ...\n}\n")),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The keeper utilizes ",(0,a.kt)("inlineCode",{parentName:"p"},"CreatePoolMsg")," interface methods to execute the logic specific\nto each pool type.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Lastly, ",(0,a.kt)("inlineCode",{parentName:"p"},"poolmanager.CreatePool")," routes the execution to the appropriate module."))),(0,a.kt)("p",null,"The propagation to the desired module is ensured by the routing table stored in memory in the ",(0,a.kt)("inlineCode",{parentName:"p"},"poolmanager")," keeper."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// x/poolmanager/keeper.go NewKeeper(...)\n\nfunc NewKeeper(...) *Keeper {\n    ...\n\n    routes := map[types.PoolType]types.SwapI{\n        types.Balancer:     gammKeeper,\n        types.Stableswap:   gammKeeper,\n        types.Concentrated: concentratedKeeper,\n    }\n\n    return &Keeper{..., routes: routes}\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"MsgCreatePool")," interface defines the following method: ",(0,a.kt)("inlineCode",{parentName:"p"},"GetPoolType() PoolType")),(0,a.kt)("p",null,"As a result, ",(0,a.kt)("inlineCode",{parentName:"p"},"poolmanagerkeeper.CreatePool")," can route the execution to the appropriate module in\nthe following way:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// x/poolmanager/creator.go CreatePool(...)\n\nswapModule := k.routes[msg.GetPoolType()]\n\nif err := swapModule.InitializePool(ctx, pool, sender); err != nil {\n    return 0, err\n}\n")),(0,a.kt)("p",null,"Where swapModule is either ",(0,a.kt)("inlineCode",{parentName:"p"},"gamm")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"concentrated-liquidity")," keeper."),(0,a.kt)("p",null,"Both of these modules implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"SwapI")," interface:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// x/poolmanager/types/routes.go SwapI interface\n\ntype SwapI interface {\n    ...\n\n    InitializePool(ctx sdk.Context, pool gammtypes.PoolI, creatorAddress sdk.AccAddress) error\n}\n")),(0,a.kt)("p",null,"As a result, the ",(0,a.kt)("inlineCode",{parentName:"p"},"poolmanager")," module propagates core execution to the appropriate swap module."),(0,a.kt)("p",null,"Lastly, the ",(0,a.kt)("inlineCode",{parentName:"p"},"poolmanager")," keeper stores a mapping from the pool id to the pool type.\nThis mapping is going to be necessary for knowing where to route the swap messages."),(0,a.kt)("p",null,"To achieve this, we create the following store index:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// x/poolmanager/types/keys.go\n\nvar (\n    ...\n\n    SwapModuleRouterPrefix     = []byte{0x02}\n)\n\n// N.B.: we proto-generate this struct. However, the proto\n// definition is omitted for brevity.\ntype ModuleRoute struct {\n    PoolType PoolType\n}\n\n// FormatModuleRouteKey serializes pool id with appropriate prefix into bytes.\nfunc FormatModuleRouteKey(poolId uint64) []byte {\n    return []byte(fmt.Sprintf("%s%d", SwapModuleRouterPrefix, poolId))\n}\n\n// ParseModuleRouteFromBz parses the raw bytes into ModuleRoute.\n// Returns error if fails to parse or if the bytes are empty.\nfunc ParseModuleRouteFromBz(bz []byte) (ModuleRoute, error) {\n    // parsing logic\n}\n')),(0,a.kt)("h2",{id:"swaps"},"Swaps"),(0,a.kt)("p",null,"There are 4 swap messages:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"MsgSwapExactAmountIn")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"MsgSwapExactAmountOut")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"MsgSplitRouteSwapExactAmountIn")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"MsgSplitRouteSwapExactAmountOut"))),(0,a.kt)("p",null,"Between, ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgSwapExactAmountIn")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgSwapExactAmountOut"),", the implementation of routing is similar. We only focus on ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgSwapExactAmountIn")," below."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"MsgSplitRouteSwapExactAmountIn")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgSplitRouteSwapExactAmountOut")," support split routes where for each split route they call the respective\n",(0,a.kt)("inlineCode",{parentName:"p"},"MsgSwapExactAmountIn")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgSwapExactAmountOut"),' message. When using the split routes, the slippage protection is disabled on the per-route basis.\nFor swap exact amount in, we provide zero for the min amount out. For swap exact amount out, we provide the max amount in which is 1 << 256 - 1.\nRead more about route splitting in the "Route Splitting" section.'),(0,a.kt)("p",null,"Once the message is received, it calls ",(0,a.kt)("inlineCode",{parentName:"p"},"RouteExactAmountIn")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// x/poolmanager/router.go RouteExactAmountIn(...)\n\n// RouteExactAmountIn defines the input denom and input amount for the first pool,\n// the output of the first pool is chained as the input for the next routed pool\n// transaction succeeds when final amount out is greater than tokenOutMinAmount defined.\nfunc (k Keeper) RouteExactAmountIn(\n    ctx sdk.Context,\n    sender sdk.AccAddress,\n    routes []types.SwapAmountInRoute,\n    tokenIn sdk.Coin,\n    tokenOutMinAmount sdk.Int) (tokenOutAmount sdk.Int, err error) {\n}\n")),(0,a.kt)("p",null,"Essentially, the method iterates over the routes and calls a ",(0,a.kt)("inlineCode",{parentName:"p"},"SwapExactAmountIn")," method\nfor each, subsequently updating the inter-pool swap state."),(0,a.kt)("p",null,"The routing works by querying the index ",(0,a.kt)("inlineCode",{parentName:"p"},"SwapModuleRouterPrefix"),",\nsearching up the ",(0,a.kt)("inlineCode",{parentName:"p"},"poolmanagerkeeper.router")," mapping, and calling\n",(0,a.kt)("inlineCode",{parentName:"p"},"SwapExactAmountIn")," method of the appropriate module."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// x/poolmanager/router.go RouteExactAmountIn(...)\n\nmoduleRouteBytes := osmoutils.MustGet(poolmanagertypes.FormatModuleRouteIndex(poolId))\nmoduleRoute, _ := poolmanagertypes.ModuleRouteFromBytes(moduleRouteBytes)\n\nswapModule := k.routes[moduleRoute.PoolType]\n\n_ := swapModule.SwapExactAmountIn(...)\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"note that error checks and other details are omitted for brevity.")),(0,a.kt)("p",null,"Similar to pool creation logic, we are able to call ",(0,a.kt)("inlineCode",{parentName:"p"},"SwapExactAmountIn")," on any of the swap\nmodules by implementing the ",(0,a.kt)("inlineCode",{parentName:"p"},"SwapI")," interface:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// x/poolmanager/types/routes.go SwapI interface\n\ntype SwapI interface {\n    ...\n\n    SwapExactAmountIn(\n        ctx sdk.Context,\n        sender sdk.AccAddress,\n        poolId gammtypes.PoolI,\n        tokenIn sdk.Coin,\n        tokenOutDenom string,\n        tokenOutMinAmount sdk.Int,\n        spreadFactor sdk.Dec,\n    ) (sdk.Int, error)\n}\n")),(0,a.kt)("p",null,"During the process of swapping a specific asset, the token the user is\nputting into the pool is denoted as ",(0,a.kt)("inlineCode",{parentName:"p"},"tokenIn"),", while the token that\nwould be returned to the user, the asset that is being swapped for,\nafter the swap is denoted as ",(0,a.kt)("inlineCode",{parentName:"p"},"tokenOut")," throughout the module."),(0,a.kt)("p",null,"For example, in the context of balancer pools, given a ",(0,a.kt)("inlineCode",{parentName:"p"},"tokenIn"),", the\nfollowing calculations are done to calculate how many tokens are to be\nswapped into and removed from the pool:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"tokenBalanceOut * [1 - { tokenBalanceIn / (tokenBalanceIn + (1 - spreadFactor) * tokenAmountIn)} ^ (tokenWeightIn / tokenWeightOut)]")),(0,a.kt)("p",null,"The calculation is also able to be reversed, the case where user\nprovides ",(0,a.kt)("inlineCode",{parentName:"p"},"tokenOut"),". The calculation for the amount of tokens that the\nuser should be putting in is done through the following formula:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"tokenBalanceIn * [{tokenBalanceOut / (tokenBalanceOut - tokenAmountOut)} ^ (tokenWeightOut / tokenWeightIn) -1] / tokenAmountIn")),(0,a.kt)("p",null,"Existing Swap types:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"SwapExactAmountIn"),(0,a.kt)("li",{parentName:"ul"},"SwapExactAmountOut")),(0,a.kt)("h2",{id:"messages"},"Messages"),(0,a.kt)("h3",{id:"msgswapexactamountin"},"MsgSwapExactAmountIn"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/osmosis/blob/f26ceb958adaaf31510e17ed88f5eab47e2bac03/proto/osmosis/gamm/v1beta1/tx.proto#L79"},"MsgSwapExactAmountIn")),(0,a.kt)("h3",{id:"msgswapexactamountout"},"MsgSwapExactAmountOut"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/osmosis/blob/f26ceb958adaaf31510e17ed88f5eab47e2bac03/proto/osmosis/gamm/v1beta1/tx.proto#L102"},"MsgSwapExactAmountOut")),(0,a.kt)("h3",{id:"msgsplitrouteswapexactamountin"},"MsgSplitRouteSwapExactAmountIn"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/osmosis/blob/46e6a0c2051a3a5ef8cdd4ecebfff7305b13ab98/proto/osmosis/poolmanager/v1beta1/tx.proto#L41"},"MsgSplitRouteSwapExactAmountIn")),(0,a.kt)("h2",{id:"msgsplitrouteswapexactamountout"},"MsgSplitRouteSwapExactAmountOut"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/osmosis/blob/46e6a0c2051a3a5ef8cdd4ecebfff7305b13ab98/proto/osmosis/poolmanager/v1beta1/tx.proto#L85"},"MsgSplitRouteSwapExactAmountOut")),(0,a.kt)("h2",{id:"multi-hop"},"Multi-Hop"),(0,a.kt)("p",null,"All tokens are swapped using a multi-hop mechanism. That is, all swaps\nare routed via the most cost-efficient way, swapping in and out from\nmultiple pools in the process.\nThe most cost-efficient route is determined offline and the list of the pools is provided externally, by user, during the broadcasting of the swapping transaction.\nAt the moment of execution, the provided route may not be the most cost-efficient one anymore."),(0,a.kt)("p",null,"When a trade consists of just two OSMO-included routes during a single transaction,\nthe spread factors on each hop would be automatically halved.\nExample: for converting ",(0,a.kt)("inlineCode",{parentName:"p"},"ATOM -> OSMO -> LUNA")," using two pools with spread factors ",(0,a.kt)("inlineCode",{parentName:"p"},"0.3% + 0.2%"),",\ninstead ",(0,a.kt)("inlineCode",{parentName:"p"},"0.15% + 0.1%")," spread factors will be applied."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/osmosis/blob/f26ceb958adaaf31510e17ed88f5eab47e2bac03/x/poolmanager/router.go#L16"},"Multi-Hop")),(0,a.kt)("h2",{id:"route-splitting"},"Route Splitting"),(0,a.kt)("p",null,"Each route can be thought of as a separate multi-hop swap."),(0,a.kt)("p",null,"Splitting swaps across multiple pools for the same token pair can be beneficial for several reasons,\nprimarily relating to reduced slippage, price impact, and potentially lower spreads."),(0,a.kt)("p",null,"Here's a detailed explanation of these advantages:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Reduced slippage"),": When a large trade is executed in a single pool, it can be significantly affected if someone else executes a large swap against that pool.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Lower price impact"),": When executing a large trade in a single pool, the price impact can be substantial, leading to a less favorable exchange rate for the trader.\nBy splitting the swap across multiple pools, the price impact in each pool is minimized, resulting in a better overall exchange rate.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Improved liquidity utilization"),": Different pools may have varying levels of liquidity, spreads, and price curves. By splitting swaps across multiple pools,\nthe router can utilize liquidity from various sources, allowing for more efficient execution of trades. This is particularly useful when the liquidity in\na single pool is not sufficient to handle a large trade or when the price curve of one pool becomes less favorable as the trade size increases.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Potentially lower spreads"),": In some cases, splitting swaps across multiple pools may result in lower overall spreads. This can happen when different pools\nhave different spread structures, or when the total spread paid across multiple pools is lower than the spread for executing the entire trade in a single pool with\nhigher slippage."))),(0,a.kt)("p",null,"Note, that the actual split happens off-chain. The router is only responsible for executing the swaps in the order and quantities of token in provided\nby the routes."))}m.isMDXComponent=!0}}]);